/******************************************************************************
 * 
 * remoteNode.ino
 *
 * Description:
 *
 * Implements a remote Meshtastic node that allows for the control of outputs 
 * and reports back the status of the outputs and inputs. The inputs and 
 * outputs can be digital or analog and are easily configured my editing
 * the input and output array. Each remote Meshtastic node can have a node 
 * name, defined by the NODENAME string. This allows multiple remote nodes
 * to share the same Meshtastic serial/data channel and respond to controls
 * for each node.
 * 
 * The Meshtastic setup involves creating a data/serial channel as the 
 * primary channel on all of the remote and control nodes. This is advised
 * so the controls and status messages are kept out of the public Meshtastic
 * channel. 
 *
 * The serial module is enabled and set up in TEXTMSG mode to allow access 
 * to the serial port via a Meshtastic message on the primary (data/serial) 
 * channel. The Meshtastic radio will communicate to the ESP8266, which is
 * running this sketch which responds to commands and gives reports on the
 * state of the inputs and outputs as follows:
 *
 * Command Message (sent by control node to remote node):
 *
 * [NODENAME]:[outputName1]=[outputValue2],[outputName2]=[outputValue2]
 *
 * e.g. n1:do1=0,ao1=128
 * 
 * where n1 is the NODENAME, do1 is a digital output, and aol is an analog
 * output.
 *
 * Report Message (sent by remote node):
 *
 * [NODENAME]:t=[timestamp],[ioName1]=[ioValue1],[ioName2]=[ioValue2]
 *
 * e.g. n1:t=3000,do1=0,ao1=128,di1=1,ai1=240
 *
 * where n1 is the NODENAME, 3000 milliseconds have passed since the node was
 * powered up, and do1 is a digital output, ao1 is an analog output, di1 is a
 * digital input, and ai1 is an analog output.
 * 
 * A report message may be generated by a timeout defined by MESHMSGFREQ, which
 * is set to 60 seconds, or a change in a digital input or output, or a change
 * in an analog output beyond a threshold of the last reported value. The 
 * messages will not be transmitted quicker than designated by MINMSGTIME, 
 * which is set to 3 seconds. Since the Meshtastic network is a slow, high 
 * latency, and shared communication network, it is not recommended to send 
 * messages more often or quicker than every 3 seconds.
 *
 * The concept of using the serial module in the TEXTMSG mode came from Core
 * Electronics Meshtastic for Makers Workshop written by Jaryd 
 * <https://core-electronics.com.au/courses/meshtastic-for-makers-workshop/?fresh>
 * 
 *
 * Author: Jonathan Weaver, jonw0224@gmail.com
 *
 * Date: 10/25/2025
 *
 * Version: 
 *
 * 1.00 - 2025-10-25 - Wrote initial code over the past three days
 * 
 * Copyright (C) 2025 Jonathan Weaver
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 *****************************************************************************/


/******************************************************************************
 * Includes
 *****************************************************************************/

// I decided to use the software UART to leave the normal UART available for
// troubleshooting and status messaging
#include <SoftwareSerial.h>

/******************************************************************************
 * Global Variables
 *****************************************************************************/

// Node identifier. This is used to filter messages only intended for this node
String NODENAME = "n1";

// Input and output definition structure
struct MeshIO {
  String name;  // Identifying name
  int pin;      // GPIO pin
  int meshSt;   // State communicated to the Meshtastic network
  int dig;      // 1 = digital, 0 = analog
  int inp;      // INPUT = input, OUTPUT = output
};

// Definitions of the inputs and outputs to communicate over the mesh
// If you wanted to add more inputs and outputs, this is where you'd do it.
MeshIO inputOutputs[] = {
  {"do1", 12, 0, 1, OUTPUT},
  {"ao1", 13, 0, 0, OUTPUT},
  {"dil", 16, 0, 1, INPUT},
  {"ail", A0, 0, 0, INPUT}
};

// inputOutputsSize
const int inputOutputsSize = sizeof(inputOutputs) / sizeof(inputOutputs[0]);

// Send the status of the inputs and outputs every 60 seconds
int MESHMSGFREQ = 60000;
// For events, do not send messages no closer than 3 seconds apart
int MINMSGTIME = 3000;

// Global variables for parsing messages and changing states of outputs
int recieveState = 0;
String recieveNode = "";
String sendNode = "";
String stateVar = "";
String stateValue = "";

// sendStateToMesh = 0 means don't send anything to mesh, 1 means we need to 
// send a message
int sendStateToMesh = 0;

// Sensitivity of the ADC. A change greater than ASENSITIVITY will trigger a 
// message
int ASENSITIVITY = 25;

// The current time in milliseconds since the last restart
int curTime;

// The last time a message was sent to the mesh
int prevTime;

// Set up a new SoftwareSerial object with RX in digital pin 4 and TX in 
// digital pin 5
SoftwareSerial mySerial(4, 5);

/******************************************************************************
 * Setup function. Called after a power on. Initializes the software.
 *****************************************************************************/
void setup() {

  // InitiLize serial ports
  Serial.begin(115200);
  mySerial.begin(115200);

  // Initialize input and output pins
  for(int i = 0; i < inputOutputsSize; i++) {
    pinMode(inputOutputs[i].pin, inputOutputs[i].inp);
  }
  
  // Keep up with time
  prevTime = millis();
  curTime = millis();
}

/******************************************************************************
 * Loop function. Called repeatedly to execute the program.
 *****************************************************************************/
void loop() {
  // Declare local variable to store the current values of inputs and outputs
  int ioCur;
  // Keep up with time
  curTime = millis();
  // If an event has occurred, we need to send a message to the mesh
  if(sendStateToMesh == 1) {
    Serial.println("sendStateToMesh = 1");
    sendMeshMsg();
  }
  // Look at all of the inputs for any changes
  for(int i = 0; i < inputOutputsSize; i++) {
    // Only look at inputs
    if(inputOutputs[i].inp == INPUT) {
      if(inputOutputs[i].dig == 0){
        // Analog input
        ioCur = analogRead(inputOutputs[i].pin);
        // If the analog input changed beyond the ASENSITIVITY setting, send a message to the mesh
        if(ioCur > inputOutputs[i].meshSt + ASENSITIVITY || ioCur < inputOutputs[i].meshSt - ASENSITIVITY) {
          Serial.println(inputOutputs[i].name + " change");
          sendMeshMsg();
        }
      } else {
        // Digital input
        ioCur = digitalRead(inputOutputs[i].pin);
        // If the digital input changed, send an update to the mesh
        if(ioCur != inputOutputs[i].meshSt){
          Serial.println(inputOutputs[i].name + " change");
          sendMeshMsg();
        }
      }
    }
  }
  // If enough time has past, we send a message to the mesh
  if(curTime - prevTime >= MESHMSGFREQ) {
    Serial.println("sendMeshTime");
    sendMeshMsg();
  }
  // Check to see if we have any pending commands from the mesh so we can 
  // update the digital and analog outputs
  recieveMeshMsg();
}

/******************************************************************************
 * Send a message to the mesh with a timestamp and a listing of the input and outputs.
 * e.g.
 * [NODENAME]:t=[millis],[input1]=[value1],[input2]=[value2],[output1]=[value1],[output2]=[value2]
 *****************************************************************************/
void sendMeshMsg() {
  // Local variable to store the input/output state
  int ioCur;
  if(curTime - prevTime >= MINMSGTIME) {
    // Send node name and timestamp
    String msgStr = NODENAME + ":t=" + curTime;
    for(int i = 0; i < inputOutputsSize; i++) {
      // Send comma because new input/output
      msgStr += ",";
      // Send name
      msgStr += inputOutputs[i].name;
      // Send equals before value
      msgStr += "=";
      // Send the value
      if(inputOutputs[i].dig == 1) {
        // Digital input or output
        ioCur = digitalRead(inputOutputs[i].pin);
        inputOutputs[i].meshSt = ioCur;
        // Determine value
        if(ioCur == HIGH) {
          msgStr += "1";
        } else {
          msgStr += "0";
        }
      } else {
        // Analog input or output
        if(inputOutputs[i].inp == OUTPUT){
          // If output, use stored value
          msgStr += inputOutputs[i].meshSt;
        } else {
          // If input, use measured value
          ioCur = analogRead(inputOutputs[i].pin);
          msgStr += ioCur;
          inputOutputs[i].meshSt = ioCur;
        }
      }
    }
    // Convert string to a character array to write to UART
    char msgCharArr[200];
    msgStr.toCharArray(msgCharArr, 200);
    // Write to UART
    mySerial.write(msgCharArr);
    // Remember the time the message was sent
    prevTime = curTime;
    // Set send state to mesh as 0 because we just sent the state to the mesh
    sendStateToMesh = 0;
  }
}

/******************************************************************************
 * Recieves a message from the mesh with a listing of the outputs and values.
 * e.g.
 * [SENDNODE]:  [NODENAME]:[output1]=[value1],[output2]=[value2]
 *****************************************************************************/
void recieveMeshMsg() {
  // Recieve a message from the UART Meshtastic Node
  while (mySerial.available()) {
    char inChar = (char)mySerial.read();
    switch(recieveState) {
      // Initialize everything
      case -1:
        sendNode = "";
        recieveNode = "";
        stateVar = "";
        stateValue = "";
        // Set the state machine to the beginning state
        recieveState = 0;
        // Fall thru to case 0
      // Recieving the sending node name, this is the initial wait state
      case 0:
        Serial.println("Recieving message");
        if(inChar == ':') {
          recieveState = 1;
        } else if (inChar == '\r' || inChar == '\n') {
          // Invalid Message
          recieveState = -1;
        } else { 
          sendNode += inChar;
        }
        break;
      // Recieving the recieving node name
      case 1:
        if(inChar == ' ') {
          // Ignore spaces
        } else if(inChar == '\r' || inChar == '\n') {
          // Invalid Message, reset
          recieveState = -1;
        } else if(inChar == ':') {
          // recieveNode recieved, advance state machine
          recieveState = 2;
        } else {
          recieveNode += inChar;
        }
        break;
      // Recieving the stateVar
      case 2:
        if(inChar == ' ') {
          // Ignore spaces
        } else if(inChar == '\r' || inChar == '\n') {
          // Invalid Message
          recieveState = -1;
        } else if(inChar == '=') {
          // stateVar recieved, advance state machine
          recieveState = 3;
        } else {
          stateVar += inChar;
        }
        break;
      // Recieving the stateValue
      case 3:
        if(inChar == '\r' || inChar == '\n') {
          // End of message, process the stateVar=stateValue
          processState();
          // Reset the recieve state machine
          recieveState = -1;
        } else if(inChar == ',') {
          // Received one stateVar=stateValue but have another in the message,
          // process this state
          processState();
          // Prepare to process the next state
          stateVar = "";
          stateValue = "";
          // Set the state machine back to parsing the next state
          recieveState = 2;
        } else {
          stateValue += inChar;
        }
        break;
    }
  }
}

/******************************************************************************
 * Implements the message recieved, setting outputs based on the message
 * e.g.
 * [SENDNODE]:  [NODENAME]:[output1]=[value1],[output2]=[value2]
 *****************************************************************************/
void processState() {
  if(recieveNode.equalsIgnoreCase(NODENAME)) {
    for(int i = 0; i < inputOutputsSize; i++) {
      if(inputOutputs[i].inp == OUTPUT) {
        // Output, not input
        if(stateVar.equalsIgnoreCase(inputOutputs[i].name)) {
          if(inputOutputs[i].dig == 1) {
            // Digital output
            if(stateValue.equals("1")) {
              digitalWrite(inputOutputs[i].pin, HIGH);
              inputOutputs[i].meshSt = HIGH;
            } else if(stateValue.equals("0")) {
              digitalWrite(inputOutputs[i].pin, LOW);
              inputOutputs[i].meshSt = LOW;
            }
            sendStateToMesh = 1;
          } else {
            // Analog output
            inputOutputs[i].meshSt = stateValue.toInt();
            analogWrite(inputOutputs[i].pin, inputOutputs[i].meshSt);
            sendStateToMesh = 1;
          }
        }
      }
    }
  }
}
